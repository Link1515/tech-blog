<!DOCTYPE html><html lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>透過源碼了解 Composer Autoload 原理 | Lynk is here</title><meta name=description content="Composer 是 PHP 的套件管理工具，用於管理專案的相依關係，而 Composer 的自動載入功能 (autoload) 允許開發人員在不指定檔案路徑的情況下使用類別。本文將深入研究 Composer 自動載入的源碼，探討其運作原理和實踐細節。"><link rel=icon type=image/x-icon href=/tech-blog/images/favicon.ico><meta property=og:type content=website><meta property=og:url content=https://link1515.github.io/tech-blog><meta property=og:title content="透過源碼了解 Composer Autoload 原理 | Lynk is here"><meta property=og:description content="Composer 是 PHP 的套件管理工具，用於管理專案的相依關係，而 Composer 的自動載入功能 (autoload) 允許開發人員在不指定檔案路徑的情況下使用類別。本文將深入研究 Composer 自動載入的源碼，探討其運作原理和實踐細節。"><meta property=og:image content=/tech-blog/images/cover/composer_autoload.jpg><meta name=twitter:card content=summary_large_image><meta name=twitter:title content="透過源碼了解 Composer Autoload 原理 | Lynk is here"><meta name=twitter:description content="Composer 是 PHP 的套件管理工具，用於管理專案的相依關係，而 Composer 的自動載入功能 (autoload) 允許開發人員在不指定檔案路徑的情況下使用類別。本文將深入研究 Composer 自動載入的源碼，探討其運作原理和實踐細節。"><meta name=twitter:image content=/tech-blog/images/cover/composer_autoload.jpg><link rel=stylesheet href=/tech-blog/lib/bootstrap/bootstrap.min.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css><link rel=stylesheet href=/tech-blog/lib/prismjs/prism.min.css><link rel=stylesheet href=/tech-blog/lib/prismjs/prism-vsc-dark-plus.css><link rel=stylesheet href=/tech-blog/css/main.css><meta name=generator content="Hexo 7.3.0"></head><body data-bs-theme=dark><script>const theme=window.localStorage.getItem("theme")??"";document.body.dataset.bsTheme=theme</script><div class="min-vh-100 d-flex flex-column"><nav id=navbar class="navbar navbar-expand-lg bg-body-tertiary sticky-top shadow-sm"><div class=container-lg><a id=logo class=navbar-brand href=/tech-blog/ ><img class=me-1 src=/tech-blog/images/logo.png height=50 alt=logo> Lynk is here </a><button class="navbar-toggler px-2" type=button data-bs-toggle=collapse data-bs-target=#navbarSupportedContent><i class="bi bi-list icon-20"></i></button><div class="collapse navbar-collapse" id=navbarSupportedContent><ul class="navbar-nav ms-auto mb-2 mb-lg-0"><li class=nav-item><a class=nav-link href=/tech-blog/ ><i class="bi bi-house-fill icon-20"></i> 首頁</a></li><li class=nav-item><a class=nav-link href=/tech-blog/archives><i class="bi bi-list-ul icon-20"></i> 列表</a></li><li class=nav-item><a class=nav-link href=/tech-blog/categories><i class="bi bi-folder-fill icon-20"></i> 分類</a></li><li class=nav-item><a class=nav-link href=/tech-blog/tags><i class="bi bi-tags-fill icon-20"></i> 標籤</a></li></ul><div class="d-flex justify-content-center"><button id=toggleThemeBtn class="toggleThemeBtn btn" style=border:none><i class="bi bi-lightbulb-fill icon-20"></i></button> <button id=searchBtn class="searchBtn btn" style=border:none data-bs-toggle=modal data-bs-target=#searchModal><i class="bi bi-search icon-20"></i></button></div></div></div></nav><div class="flex-grow-1 container-lg mt-4 mb-5"><div class=post><h1>透過源碼了解 Composer Autoload 原理</h1><small class=text-body-secondary><time datetime=2024-04-20T00:00:00.000Z>2024-04-20</time></small><hr><div class="d-flex flex-column gap-2 mb-4"><div><div class="d-flex flex-wrap gap-2"><a href=/tech-blog/categories/Backend/ class="btn btn-secondary btn-sm"><i class="bi bi-folder-fill icon-15"></i> Backend</a></div></div><div><div class="tagLinks d-flex flex-wrap gap-2"><a href=/tech-blog/tags/PHP/ class="btn btn-secondary btn-sm"><i class="bi bi-tag-fill icon-15"></i> PHP </a><a href=/tech-blog/tags/Composer/ class="btn btn-secondary btn-sm"><i class="bi bi-tag-fill icon-15"></i> Composer</a></div></div></div><div class="text-center mb-4"><img class="img-fluid rounded" width=1200 height=630 src=/tech-blog/images/cover/composer_autoload.jpg alt=cover></div><div class=content><p>Composer 是 PHP 的套件管理工具，用於管理專案的相依關係，而 Composer 的自動載入功能 (autoload) 允許開發人員在不指定檔案路徑的情況下使用類別。本文將深入研究 Composer 自動載入的源碼，探討其運作原理和實踐細節。</p><blockquote><p>本文章使用 composer 2.7.2</p></blockquote><h2 id=入口><a href=#入口 class=headerlink title=入口></a>入口</h2><p><code>/vendor/autoload.php</code></p><p>我們使用 composer 管理套件時，都需要先引入 <code>vendor/autoload.php</code>，因此我們先看到這個檔案</p><pre class=language-PHP data-language=PHP><code class=language-PHP>&lt;?php

&#x2F;&#x2F; autoload.php @generated by Composer

&#x2F;&#x2F; 如果 php 是 5.6 以下 composer 就需要使用 2.2 本版
&#x2F;&#x2F; 可以使用指令: composer self-update --2.2
if (PHP_VERSION_ID &lt; 50600) &#123;
    if (!headers_sent()) &#123;
        header(&#39;HTTP&#x2F;1.1 500 Internal Server Error&#39;);
    &#125;
    $err &#x3D; &#39;Composer 2.3.0 dropped support for autoloading on PHP &lt;5.6 and you are running &#39;.PHP_VERSION.&#39;, please upgrade PHP or use Composer 2.2 LTS via &quot;composer self-update --2.2&quot;. Aborting.&#39;.PHP_EOL;
    if (!ini_get(&#39;display_errors&#39;)) &#123;
        if (PHP_SAPI &#x3D;&#x3D;&#x3D; &#39;cli&#39; || PHP_SAPI &#x3D;&#x3D;&#x3D; &#39;phpdbg&#39;) &#123;
            fwrite(STDERR, $err);
        &#125; elseif (!headers_sent()) &#123;
            echo $err;
        &#125;
    &#125;
    trigger_error(
        $err,
        E_USER_ERROR
    );
&#125;

&#x2F;&#x2F; 引入 ComposerAutoloaderInit 類 (類的後面會帶上 hash)
require_once __DIR__ . &#39;&#x2F;composer&#x2F;autoload_real.php&#39;;

&#x2F;&#x2F; 使用 ComposerAutoloaderInit 類上的 getLoader() 靜態方法
return ComposerAutoloaderInitf70435b34cb6d4560a03336f9a2766b6::getLoader();</code></pre><h2 id=ComposerAutoloaderInit-類><a href=#ComposerAutoloaderInit-類 class=headerlink title="ComposerAutoloaderInit 類"></a>ComposerAutoloaderInit 類</h2><p><code>/vendor/composer/autoload_real.php</code></p><p>在入口文件中，會發現引入了 <code>/vendor/composer/autoload_real.php</code>，裡面定義的是 <code>ComposerAutoloaderInit</code> 類，類名的後面會加上 hash</p><p>接下來可以跟著註解的編號讀</p><pre class=language-PHP data-language=PHP><code class=language-PHP>&lt;?php
&#x2F;&#x2F; autoload_real.php @generated by Composer

class ComposerAutoloaderInitf70435b34cb6d4560a03336f9a2766b6
&#123;
    private static $loader;

    &#x2F;**
     * &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;
     *     2
     * &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;
     * 從 getLoader() 可以知道這個方法被註冊為自動加載函數
     *&#x2F;
    public static function loadClassLoader($class)
    &#123;
        &#x2F;&#x2F; 如果類名是 Composer\Autoload\ClassLoader，就去引入 &#x2F;vendor&#x2F;composer&#x2F;ClassLoader.php
        if (&#39;Composer\Autoload\ClassLoader&#39; &#x3D;&#x3D;&#x3D; $class) &#123;
            require __DIR__ . &#39;&#x2F;ClassLoader.php&#39;;
        &#125;
    &#125;

    &#x2F;**
     * &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;
     *     1
     * &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;
     * 從入口文件中，我們得知會去調用 getLoader() 這個靜態方法，因此先從這裡開始看
     *&#x2F;
    &#x2F;**
     * @return \Composer\Autoload\ClassLoader
     *&#x2F;
    public static function getLoader()
    &#123;
        &#x2F;&#x2F; 先確認有沒有已經創建的 loader，如果有就直接用
        if (null !&#x3D;&#x3D; self::$loader) &#123;
            return self::$loader;
        &#125;

        &#x2F;&#x2F; 做一些版本檢測，可以先忽略
        require __DIR__ . &#39;&#x2F;platform_check.php&#39;;

        &#x2F;&#x2F; 註冊一個自動加載函數，這個函數會在類被使用時自動去調用
        &#x2F;&#x2F; 這裡註冊此類上的 loadClassLoader() 方法
        spl_autoload_register(array(&#39;ComposerAutoloaderInitf70435b34cb6d4560a03336f9a2766b6&#39;, &#39;loadClassLoader&#39;), true, true);
        &#x2F;&#x2F; 造一個 \Composer\Autoload\ClassLoader 類
        &#x2F;&#x2F; 此時會自動使用剛剛註冊的 loadClassLoader() 函數
        self::$loader &#x3D; $loader &#x3D; new \Composer\Autoload\ClassLoader(\dirname(__DIR__));
        &#x2F;&#x2F; 解除 loadClassLoader()，後續直接透過 $loader
        spl_autoload_unregister(array(&#39;ComposerAutoloaderInitf70435b34cb6d4560a03336f9a2766b6&#39;, &#39;loadClassLoader&#39;));

        &#x2F;&#x2F; 引入 ComposerStaticInit 類
        require __DIR__ . &#39;&#x2F;autoload_static.php&#39;;
        &#x2F;&#x2F; 調用 ComposerStaticInit 類上的 getInitializer() 方法返回的函數
        &#x2F;&#x2F; 目的在於在 $loader 上加入 class 對應到的檔案
        call_user_func(\Composer\Autoload\ComposerStaticInitf70435b34cb6d4560a03336f9a2766b6::getInitializer($loader));

        &#x2F;&#x2F; 調用 $loader 上的 register() 方法，相當於啟動 $loader
        $loader-&gt;register(true);

        return $loader;
    &#125;
&#125;</code></pre><h2 id=ComposerStaticInit-類><a href=#ComposerStaticInit-類 class=headerlink title="ComposerStaticInit 類"></a>ComposerStaticInit 類</h2><p><code>/vendor/composer/autoload_static.php</code></p><p>靜態初始化，這隻檔案用來直接告訴 <code>$loader</code> 我們使用的 <code>namespace</code> 對應到的目錄</p><pre class=language-PHP data-language=PHP><code class=language-PHP>&lt;?php

&#x2F;&#x2F; autoload_static.php @generated by Composer

namespace Composer\Autoload;

class ComposerStaticInitf70435b34cb6d4560a03336f9a2766b6
&#123;
    &#x2F;&#x2F; 用起始字母來排列 namespace 提高查詢效率
    public static $prefixLengthsPsr4 &#x3D; array (
        &#39;L&#39; &#x3D;&gt;
        array (
            &#39;Lynk\\TestPhp\\&#39; &#x3D;&gt; 13,
        ),
    );

    &#x2F;&#x2F; namespace 實際對應到的目錄
    public static $prefixDirsPsr4 &#x3D; array (
        &#39;Lynk\\TestPhp\\&#39; &#x3D;&gt;
        array (
            0 &#x3D;&gt; __DIR__ . &#39;&#x2F;..&#x2F;..&#39; . &#39;&#x2F;php&#39;,
        ),
    );

    public static $classMap &#x3D; array (
        &#39;Composer\\InstalledVersions&#39; &#x3D;&gt; __DIR__ . &#39;&#x2F;..&#39; . &#39;&#x2F;composer&#x2F;InstalledVersions.php&#39;,
    );

    &#x2F;&#x2F; 將這些映射關係都放到 $loader 上
    public static function getInitializer(ClassLoader $loader)
    &#123;
        return \Closure::bind(function () use ($loader) &#123;
            $loader-&gt;prefixLengthsPsr4 &#x3D; ComposerStaticInitf70435b34cb6d4560a03336f9a2766b6::$prefixLengthsPsr4;
            $loader-&gt;prefixDirsPsr4 &#x3D; ComposerStaticInitf70435b34cb6d4560a03336f9a2766b6::$prefixDirsPsr4;
            $loader-&gt;classMap &#x3D; ComposerStaticInitf70435b34cb6d4560a03336f9a2766b6::$classMap;

        &#125;, null, ClassLoader::class);
    &#125;
&#125;</code></pre><h2 id=ClassLoader-類><a href=#ClassLoader-類 class=headerlink title="ClassLoader 類"></a>ClassLoader 類</h2><p><code>/vendor/composer/ClassLoader.php</code></p><p>用來創建 <code>$loader</code> 的類，內部封裝真正使用的自動載入函數，也就是說，我們在使用類時，是透過 <code>$loader</code> 內的函數來引入對應的檔案</p><p>此部分，我們集中在依照 <code>PSR-4</code> 規範自動引入的幾個方法</p><h3 id=register><a href=#register class=headerlink title=register()></a>register()</h3><p>這個方法先前 <code>/vendor/composer/autoload_real.php</code> 檔案的最後可以發現有調用此方法，負責啟用 <code>$loader</code>，直接看到方法中的第一行</p><pre class=language-PHP data-language=PHP><code class=language-PHP>public function register($prepend &#x3D; false)
&#123;
    &#x2F;&#x2F; 註冊一個自動加載函數，這個函數會在類被使用時自動去調用
    &#x2F;&#x2F; 這裡註冊此類上的 loadClass() 方法
    spl_autoload_register(array($this, &#39;loadClass&#39;), true, $prepend);
    &#x2F;&#x2F; ...
&#125;</code></pre><h3 id=loadClass><a href=#loadClass class=headerlink title=loadClass()></a>loadClass()</h3><p>在 <code>register()</code> 方法中，可以看到 <code>loadClass()</code> 註冊為自動載入方法，而此方法做以下兩件事</p><ul><li>以類名找相對應的檔案</li><li>引入檔案</li></ul><pre class=language-PHP data-language=PHP><code class=language-PHP>public function loadClass($class)
&#123;
    &#x2F;&#x2F; $class 為類名，此處透過 findFile() 方法去找對應的檔案
    &#x2F;&#x2F; 如果找到了就引入該檔案
    if ($file &#x3D; $this-&gt;findFile($class)) &#123;
        $includeFile &#x3D; self::$includeFile;
        $includeFile($file);

        return true;
    &#125;

    return null;
&#125;</code></pre><h3 id=findFile><a href=#findFile class=headerlink title=findFile()></a>findFile()</h3><p>從 <code>loadClass()</code> 方法中，我們知道是透過 <code>findFile()</code> 方法透過類名去找檔案。這個方法有多種找檔案的判斷，我們使用的 <code>PSR-4</code> 是在 <code>findFileWithExtension()</code> 方法中</p><pre class=language-PHP data-language=PHP><code class=language-PHP>public function findFile($class)
&#123;
    &#x2F;&#x2F; ...

    $file &#x3D; $this-&gt;findFileWithExtension($class, &#39;.php&#39;);

    &#x2F;&#x2F; ...

    return $file;
&#125;</code></pre><h3 id=findFileWithExtension><a href=#findFileWithExtension class=headerlink title=findFileWithExtension()></a>findFileWithExtension()</h3><p>此方法中，分別有使用 <code>PSR-4</code> 與 <code>PSR-0</code> 的找檔案方式，我們只關注 <code>PSR-4</code> 的部分</p><pre class=language-PHP data-language=PHP><code class=language-PHP>private function findFileWithExtension($class, $ext)
&#123;
    &#x2F;&#x2F; PSR-4 lookup
    &#x2F;&#x2F; PSR-4 的 namespace + 檔案路徑 + 副檔名
    $logicalPathPsr4 &#x3D; strtr($class, &#39;\\&#39;, DIRECTORY_SEPARATOR) . $ext;

    &#x2F;&#x2F; 取得 namespace 的第一個字母，並對 prefixLengthsPsr4 陣列進行查找
    $first &#x3D; $class[0];
    if (isset($this-&gt;prefixLengthsPsr4[$first])) &#123;
        $subPath &#x3D; $class;
        &#x2F;&#x2F; 以 \ 為間隔，持續縮短類名，直到找到正確的 namespace
        &#x2F;&#x2F; ex:
        &#x2F;&#x2F; Lynk\MyProject\Controller\UserController\
        &#x2F;&#x2F; Lynk\MyProject\Controller\
        &#x2F;&#x2F; Lynk\MyProject\
        &#x2F;&#x2F; &#x3D;&gt; 找到 namespace
        while (false !&#x3D;&#x3D; $lastPos &#x3D; strrpos($subPath, &#39;\\&#39;)) &#123;
            $subPath &#x3D; substr($subPath, 0, $lastPos);
            $search &#x3D; $subPath . &#39;\\&#39;;
            &#x2F;&#x2F; 對比 prefixDirsPsr4 看是不是找到正確的 namespace
            if (isset($this-&gt;prefixDirsPsr4[$search])) &#123;
                $pathEnd &#x3D; DIRECTORY_SEPARATOR . substr($logicalPathPsr4, $lastPos + 1);
                &#x2F;&#x2F; 檢查路徑 + 檔名後的檔案是否存在，如果存在就返回
                foreach ($this-&gt;prefixDirsPsr4[$search] as $dir) &#123;
                    if (file_exists($file &#x3D; $dir . $pathEnd)) &#123;
                        return $file;
                    &#125;
                &#125;
            &#125;
        &#125;
    &#125;

    &#x2F;&#x2F; ...
&#125;</code></pre><h2 id=結論><a href=#結論 class=headerlink title=結論></a>結論</h2><p>整個 Autoload 的流程本質上為在 <code>spl_autoload_register()</code> 上註冊一個函數，這個函數會在我們使用 class 時自動被調用，而在函數中，會幫我們把當前 class 所在的檔案引入</p></div></div></div><footer class="footer border-top text-center py-3"><div class="container-lg text-body-secondary">© Copyright 2024 By Terry Lin</div></footer></div><div class="modal fade" id=searchModal tabindex=-1><div class=modal-dialog><div class=modal-content><div class=modal-body><div class="position-relative mb-3"><input id=searchInput class=form-control type=search style=padding-left:2.25rem> <span class="position-absolute top-50 translate-middle-y search-icon" style=left:.75rem><i class="bi bi-search"></i></span></div><div id=searchResults class="list-group list-group-flush"></div><div id=searchNoResult class="list-group list-group-flush" style=display:none><span class=list-group-item>查無結果</span></div></div></div></div></div><div class=goTopBtn><button id=goTopBtn class=shadow-sm><i class="bi bi-chevron-up"></i></button></div><script src=/tech-blog/lib/bootstrap/bootstrap.bundle.min.js></script><script src=/tech-blog/lib/prismjs/prism.min.js></script><script src=/tech-blog/lib/fuse/fuse.js></script><script src=/tech-blog/js/utils.js></script><script src=/tech-blog/js/main.js type=module></script></body></html>